{"meta":{"title":"Robin's site","subtitle":"","description":"","author":"Robin","url":"http://Roooooobin.github.io","root":"/"},"pages":[],"posts":[{"title":"Number of Islands Solution","slug":"Number-of-Islands-Solution","date":"2020-06-09T13:49:24.000Z","updated":"2020-06-09T13:59:26.756Z","comments":true,"path":"2020/06/09/Number-of-Islands-Solution/","link":"","permalink":"http://roooooobin.github.io/2020/06/09/Number-of-Islands-Solution/","excerpt":"","text":"Leetcode200 Number of Islands原文地址 给一个二维矩阵，1表示陆地，0表示水，求问有多少个岛屿，岛屿定义为被水包围的一片陆地，陆地之间上下左右连接，假定矩阵四边范围外的都是水 典型的DFS题，题目一般都会有“一片”的概念，通过某一个点以一定的范围（上下左右或九宫格）向外延伸直到无法延伸，这样就形成了一个“一片”，也即答案++，在延伸的同时将访问到的点都作标记，以免重复。遍历整个矩阵，答案就是这样的起始点的个数。 本题代码123456789101112131415161718192021public static void dfs(char[][] grid, int i, int j)&#123; if(i &lt; 0 || i &gt;= grid.length || j &lt; 0 || j &gt;= grid[i].length || grid[i][j] == '0') return; grid[i][j] = '0'; dfs(grid, i+1, j); dfs(grid, i-1, j); dfs(grid, i, j+1); dfs(grid, i, j-1);&#125;public static int numIslands(char[][] grid)&#123; int cnt = 0; for(int i=0; i&lt;grid.length; ++i)&#123; for(int j=0; j&lt;grid[i].length; ++j)&#123; if(grid[i][j] == '1')&#123; dfs(grid, i, j); cnt++; &#125; &#125; &#125; return cnt;&#125;","categories":[{"name":"Programming Problem","slug":"Programming-Problem","permalink":"http://roooooobin.github.io/categories/Programming-Problem/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://roooooobin.github.io/tags/Java/"},{"name":"Amazon","slug":"Amazon","permalink":"http://roooooobin.github.io/tags/Amazon/"},{"name":"DFS","slug":"DFS","permalink":"http://roooooobin.github.io/tags/DFS/"}]},{"title":"Search Suggestions System Solution","slug":"Search-Suggestions-System-Solution","date":"2020-06-08T13:20:44.000Z","updated":"2020-06-09T13:57:22.878Z","comments":true,"path":"2020/06/08/Search-Suggestions-System-Solution/","link":"","permalink":"http://roooooobin.github.io/2020/06/08/Search-Suggestions-System-Solution/","excerpt":"","text":"Leetcode1268 Search Suggestions System原文地址 给定一些字符串称为产品和一个搜索词，模拟搜索产品时逐个输入字符时应该输出的结果（产品的前缀等于当前输入）。每次最多给出三个结果并按照字典序排序。 比如products = [“mobile”,”mouse”,”moneypot”,”monitor”,”mousepad”]，searchWord = “mouse” 首先输入”m”，按照顺序存在前缀为”m”的产品有[“mobile”,”moneypot”,”monitor”] … 输入”mou”时，结果只有[“mouse”, “mousepad”] …依此类推 解法一 前缀二分匹配实际上就是模拟一个搜索引擎，对搜索词的所有前缀，在产品字符串数组中以前缀二分查找，然后往后最多匹配3个，返回结果。 本题代码：123456789101112131415161718192021222324252627282930313233public static int binarySearch(String[] products, String word) &#123; int len = word.length(); int l = 0, r = products.length - 1; while (l &lt;= r) &#123; int midIdx = l + (r - l) / 2; String midWhole = products[midIdx]; String midSubString = midWhole.substring(0, Math.min(midWhole.length(), len)); if (midSubString.compareTo(word) &lt; 0) &#123; l = midIdx + 1; &#125; else &#123; r = midIdx - 1; &#125; &#125; return l;&#125;public static List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123; Arrays.sort(products); List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); for (int i=1; i&lt;=searchWord.length(); ++i) &#123; String word = searchWord.substring(0, i); int lowerBound = binarySearch(products, word); List&lt;String&gt; res = new ArrayList&lt;&gt;(); for (int j=lowerBound; j&lt;Math.min(lowerBound+3, products.length); ++j) &#123; if (products[j].substring(0, Math.min(products[j].length(), i)).equals(word)) &#123; res.add(products[j]); &#125; &#125; ans.add(res); &#125; return ans;&#125; 解法二 Trie来自题解 想到前缀，一个特殊的数据结构Trie一般能派上用场，有兴趣可以研究研究 代码：123456789101112131415161718192021222324252627282930313233343536373839404142public List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123; //sort words so they will be added in a sorted order to nodes Arrays.sort(products); Trie root = new Trie(); for (String prod : products) &#123; Trie n = root; for (char ch : prod.toCharArray()) &#123; int i = ch - 'a'; if (n.next[i] == null) &#123; n.next[i] = new Trie(); &#125; n = n.next[i]; if (n.words.size() &lt; 3) n.words.add(prod); &#125; &#125; List&lt;List&lt;String&gt;&gt; res = new ArrayList(); Trie n = root; //start going over the search word char by char for (int i = 0; i &lt; searchWord.length(); i++) &#123; n = n.next[searchWord.charAt(i) - 'a']; //if we met null - means no more matches possible, the result of result can be filled by empty lists if (n == null) &#123; for (int j = i; j &lt; searchWord.length(); j++) res.add(Collections.EMPTY_LIST); break; &#125; res.add(n.words); &#125; return res;&#125;//trie nodeclass Trie &#123; Trie[] next; List&lt;String&gt; words; Trie() &#123; words = new ArrayList(); next = new Trie[26]; &#125;&#125;","categories":[{"name":"Programming Problem","slug":"Programming-Problem","permalink":"http://roooooobin.github.io/categories/Programming-Problem/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://roooooobin.github.io/tags/Java/"},{"name":"Amazon","slug":"Amazon","permalink":"http://roooooobin.github.io/tags/Amazon/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://roooooobin.github.io/tags/Binary-Search/"}]},{"title":"Zombie in Matrix(BFS)","slug":"Zombie-in-Matrix-BFS","date":"2020-06-07T13:11:24.000Z","updated":"2020-06-09T13:57:40.911Z","comments":true,"path":"2020/06/07/Zombie-in-Matrix-BFS/","link":"","permalink":"http://roooooobin.github.io/2020/06/07/Zombie-in-Matrix-BFS/","excerpt":"","text":"Zombie in Matrix(BFS)原文地址 给定一个二维矩阵， 值为1表示僵尸，0表示人类，每个僵尸每小时可以感染上下左右相邻的人类，求问多少小时后所有人类都被感染 非常标准的BFS题，一般的题面都是某一些特殊的元素（比如本题的僵尸）可以对相邻的（比如上下左右或九宫格）元素进行一定的操作（比如本题的所谓的感染）。 解题思路也很明确，数据结构使用队列 初始化。将最开始的所有特殊元素加入到队列中。 扩展队列。题目一般要求记录多少步完成“任务”，所以每一批扩展的元素不能混在一起加入队列。首先记录每一步扩展的个数，也即在扩展前队列的queue.size()，每一次扩展仅访问这么多的元素。 取出队首并队首出队，找到该元素的所有满足题意的相邻元素（满足题意一般是1.没有越界 2.满足一定条件（比如本题的只有人才会被感染）），将这些元素入队，并且记录他们，以免重复访问 返回结果。当队列为空时表示无法扩展，那么如果已经完成题目要求的“任务”则返回步数，否则返回无法完成的标识（一般是-1） 本题代码：12345678910111213141516171819202122232425262728293031323334353637383940public static int minHours(List&lt;List&lt;Integer&gt;&gt; grid) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int count = 0; int rows = grid.size(); if (rows == 0) return -1; int columns = grid.get(0).size(); if (columns == 0) return -1; for (int i=0; i&lt;rows; ++i) &#123; for (int j=0; j&lt;columns; ++j) &#123; if (grid.get(i).get(j) == 1) &#123; queue.offer(new int[]&#123;i, j&#125;); count++; &#125; &#125; &#125; int[][] directions = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; int min = 0; int target = rows * columns; while (true) &#123; int len = queue.size(); if (len == 0) break; if (count == target) return min; while (len &gt; 0) &#123; len--; int[] cur = queue.poll(); for (int[] direction : directions) &#123; int[] next = &#123;cur[0] + direction[0], cur[1] + direction[1]&#125;; int x = next[0]; int y = next[1]; if (x &gt;= 0 &amp;&amp; x &lt; rows &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; columns &amp;&amp; grid.get(x).get(y) == 0) &#123; count++; grid.get(x).set(y, 1); queue.offer(next); &#125; &#125; &#125; min++; &#125; return -1;&#125; 下面继续介绍两个典型的BFS题 Leetcode994 Rotting Oranges原文地址 仍然是标准的BFS题，本题背景改为了腐烂的橙子，每个腐烂的橙子每分钟会让上下左右相邻的新鲜橙子腐烂，本题有个变化是存在空的单元格，但其实处理起来区别不大，只不过最后完成的任务不是所有格子都是腐烂的橙子，而是所有非空格子 本题代码12345678910111213141516171819202122232425262728293031323334353637public int orangesRotting(int[][] grid) &#123; int n = grid.length; int m = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int target = n * m; for (int i=0; i&lt;n; ++i) &#123; for (int j=0; j&lt;m; ++j) &#123; if (grid[i][j] == 2) &#123; queue.offer(new int[]&#123;i, j&#125;); &#125; else if(grid[i][j] == 0) &#123; target--; &#125; &#125; &#125; if (target == 0) return 0; int minute = 0; int[][] directions = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; while (!queue.isEmpty()) &#123; int count = queue.size(); target -= count; if (target == 0) return minute; for (int i=0; i&lt;count; ++i) &#123; int[] cur = queue.poll(); for (int[] direction : directions) &#123; int x = cur[0] + direction[0]; int y = cur[1] + direction[1]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; grid[x][y] == 1) &#123; queue.offer(new int[]&#123;x, y&#125;); grid[x][y] = 2; &#125; &#125; &#125; minute++; &#125; return -1;&#125; Leetcode286 Walls and Gates原文地址 本题在Leetcode上是付费题，可以在上面的Lintcode中看到题面 依然是BFS题，背景变为了求每个空房间到门的距离，与前两题不同的是，任务不是返回最后多少步，而是将每个步数填入访问的元素中 本题代码123456789101112131415161718192021222324252627282930313233public void wallsAndGates(int[][] rooms) &#123; int n = rooms.length; int m = rooms[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); for (int i=0; i&lt;n; ++i) &#123; for (int j=0; j&lt;m; ++j) &#123; if (rooms[i][j] == 0) &#123; queue.offer(new int[]&#123;i, j&#125;); &#125; &#125; &#125; int distance = 1; final int INF = 2147483647; int[][] directions = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; while (true) &#123; int cnt = queue.size(); if (cnt == 0) break; while (cnt &gt; 0) &#123; cnt--; int[] cur = queue.poll(); for (int[] direction : directions) &#123; int[] next = &#123;cur[0] + direction[0], cur[1] + direction[1]&#125;; int x = next[0]; int y = next[1]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; rooms[x][y] == INF) &#123; rooms[x][y] = distance; queue.offer(next); &#125; &#125; &#125; distance++; &#125;&#125; Conclusion and points 题面所要求的任务目标，可能是对矩阵本身做一些修改，比如第三题中，要将距离（扩展的步数）填入到矩阵中，或者大部分的直接返回将所有元素“覆盖”（感染、腐烂）的总步数 扩展的新元素需要满足的条件，首要条件是不能越界。齐次是尚未“覆盖”的元素 对于当前扩展的新元素，需要记录他们已经访问过，可以加入Set，或者直接修改其元素值当做标记 其他点：取出队首同时队首要出队使用poll()即可；每一步扩展的元素是扩展前队列的大小；注意扩展方向是上下左右还是九宫格","categories":[{"name":"Programming Problem","slug":"Programming-Problem","permalink":"http://roooooobin.github.io/categories/Programming-Problem/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://roooooobin.github.io/tags/Java/"},{"name":"Amazon","slug":"Amazon","permalink":"http://roooooobin.github.io/tags/Amazon/"},{"name":"BFS","slug":"BFS","permalink":"http://roooooobin.github.io/tags/BFS/"}]},{"title":"Reorder Data in Log Files Solution","slug":"Reorder-Data-in-Log-Files-Solution","date":"2020-06-03T02:01:01.000Z","updated":"2020-06-09T13:56:45.807Z","comments":true,"path":"2020/06/03/Reorder-Data-in-Log-Files-Solution/","link":"","permalink":"http://roooooobin.github.io/2020/06/03/Reorder-Data-in-Log-Files-Solution/","excerpt":"","text":"Leetcode937 Reorder Data in Log Files原文地址 有一系列logs, 每条log由以空格分开的若干单词组成, 第一个单词为标识符, 后面的为正文, 通过正文可以将log分为两类, 字母log和数字log 要求排序, 字母log必须在数字log前, 字母log间按照log正文的字典序排序, 如果正文相同则按标识符排序, 数字log直接保持原序 题目已经很明显的告诉我们这是一个自定义排序题了 下面有三个实现方法, 其中两个使用了lambda匿名函数, 还有一个实现了自定义Comparator 解法一 lambda+空格分离使用lambda匿名函数, 但是分解标识符和正文的方法比较愚蠢, 方法是找到第一个空格从而分开 12345678910111213141516171819public String[] reorderLogFiles(String[] logs) &#123; Arrays.sort(logs, (log1, log2) -&gt; &#123; int idxOfFirstChar1 = log1.indexOf(' ') + 1; int idxOfFirstChar2 = log2.indexOf(' ') + 1; boolean isDigit1 = Character.isDigit(log1.charAt(idxOfFirstChar1)); boolean isDigit2 = Character.isDigit(log2.charAt(idxOfFirstChar2)); // 字母log按照字典序排序 if (!isDigit1 &amp;&amp; !isDigit2) &#123; String log1WithoutId = log1.substring(idxOfFirstChar1); String log2WithoutId = log2.substring(idxOfFirstChar2); int cmp = log1WithoutId.compareTo(log2WithoutId); if (cmp != 0) return cmp; else return log1.substring(0, idxOfFirstChar1-1).compareTo(log2.substring(0, idxOfFirstChar2-1)); &#125; // 字母log一定在数字log前面 else return isDigit1 ? (isDigit2 ? 0: 1) : -1; &#125;); return logs;&#125; 解法二 lambda+split可以使用split方法配合limit参数分解正文和标识符 split(regex, limit)表示对regex模式仅匹配limit-1次, 也即最终得到的数组长度最多为limit 比如本题标识符和正文之间由1个空格分开, 那么使用split(&quot; &quot;, 2)表示仅匹配空格1次, 分离成包含两个元素的数组 123456789101112131415public String[] reorderLogFiles(String[] logs) &#123; Arrays.sort(logs, (log1, log2) -&gt; &#123; String[] split1 = log1.split(\" \", 2); String[] split2 = log2.split(\" \", 2); boolean isDigit1 = Character.isDigit(split1[1].charAt(0)); boolean isDigit2 = Character.isDigit(split2[1].charAt(0)); if (!isDigit1 &amp;&amp; !isDigit2) &#123; int cmp = split1[1].compareTo(split2[1]); if (cmp != 0) return cmp; return split1[0].compareTo(split2[0]); &#125; return isDigit1 ? (isDigit2 ? 0 : 1) : -1; &#125;); return logs;&#125; 解法三 自定义Comparator创建一个新的Comparator并且重写compare方法 12345678910111213141516171819public String[] reorderLogFiles(String[] logs) &#123; Comparator&lt;String&gt; myComparator = new Comparator&lt;String&gt;() &#123; @Override public int compare(String log1, String log2) &#123; String[] split1 = log1.split(\" \", 2); String[] split2 = log2.split(\" \", 2); boolean isDigit1 = Character.isDigit(split1[1].charAt(0)); boolean isDigit2 = Character.isDigit(split2[1].charAt(0)); if (!isDigit1 &amp;&amp; !isDigit2) &#123; int cmp = split1[1].compareTo(split2[1]); if (cmp != 0) return cmp; return split1[0].compareTo(split2[0]); &#125; return isDigit1 ? (isDigit2 ? 0 : 1) : -1; &#125; &#125;; Arrays.sort(logs, myComparator); return logs;&#125; Key Points 熟悉lambda语法() -&gt; {} split用法, limit参数的含义 compareTo方法返回的是0/1/-1, 所以不能直接放入判断语句(与c++不同)","categories":[{"name":"Programming Problem","slug":"Programming-Problem","permalink":"http://roooooobin.github.io/categories/Programming-Problem/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://roooooobin.github.io/tags/Java/"},{"name":"Amazon","slug":"Amazon","permalink":"http://roooooobin.github.io/tags/Amazon/"},{"name":"Sorting","slug":"Sorting","permalink":"http://roooooobin.github.io/tags/Sorting/"}]},{"title":"Amazon OA Questions","slug":"Amazon-OA-Questions","date":"2020-06-03T01:50:18.000Z","updated":"2020-06-09T13:58:20.116Z","comments":true,"path":"2020/06/03/Amazon-OA-Questions/","link":"","permalink":"http://roooooobin.github.io/2020/06/03/Amazon-OA-Questions/","excerpt":"","text":"Amazon Online Assessment Questions原文地址 原文总结了亚麻线上编程题以及相应解答, 我将一一尝试并附上自己的想法, 欢迎讨论 Questions Top K Frequently Mentioned Keywords ⭐⭐⭐ [Experienced] Zombie in Matrix (Min hours to send file to all available servers) ⭐⭐⭐ [Experienced] 我的解答 Critical Routers ⭐⭐ [New Grad | Experienced] Product Suggestions ⭐⭐ [New Grad | Experienced] 我的解答 Number of Clusters ⭐⭐ [Experienced] 我的解答 Reorder Data in Log Files ⭐⭐ [Experienced] 我的解答 Partition Labels ⭐ [Experienced] Optimal Utilization [Experienced] Min Cost to Connect Ropes / Min Time to Merge Files [Experienced] Treasure Island / Min Distance to Remove the Obstacle (BFS) [Experienced] Treasure Island II Find Pair With Given Sum ⭐⭐ [Experienced, Intern] Copy List with Random Pointer ⭐⭐ [New Grad] Merge Two Sorted Lists ⭐⭐ [New Grad | Intern] Subtree of Another Tree ⭐⭐ [New Grad] Search a 2D Matrix II ⭐⭐ [New Grad] Critical Connections ⭐ [New Grad] Favorite Genres ⭐⭐ [New Grad] Two Sum - Unique Pairs ⭐⭐ [New Grad] Spiral Matrix ⭐ [New Grad] Count substrings with exactly K distinct chars ⭐ [Intern] Max Of Min Altitudes ⭐⭐ [Intern] Longest Palindromic Substring ⭐⭐ [Intern] Substrings of size K with K distinct chars ⭐⭐ [Intern] Most Common Word ⭐⭐ [Intern] K Closest Points to Origin ⭐ [Intern] Generate Parentheses ⭐ [Intern] Min Cost to Connect All Nodes (a.k.a. Min Cost to Add New Roads) Min Cost to Repair Edges (MST) Prison Cells After N Days Subtree with Maximum Average Load Balancer [Experienced] Battleship Point of Lattice ⭐ [Experienced] Merge Intervals ⭐ Longest string without 3 consecutive characters Longest string made up of only vowels Number of Dice Rolls With Target Sum Find N Unique Integers Sum Up To Zero Number of Dice Rolls with Target Sum Nth GP AMCAT Interface","categories":[{"name":"Interview","slug":"Interview","permalink":"http://roooooobin.github.io/categories/Interview/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://roooooobin.github.io/tags/Java/"},{"name":"Amazon","slug":"Amazon","permalink":"http://roooooobin.github.io/tags/Amazon/"},{"name":"OA","slug":"OA","permalink":"http://roooooobin.github.io/tags/OA/"}]},{"title":"Core Java Chapter9","slug":"Core-Java-Chapter9","date":"2020-05-31T08:52:25.000Z","updated":"2020-06-04T12:12:24.873Z","comments":true,"path":"2020/05/31/Core-Java-Chapter9/","link":"","permalink":"http://roooooobin.github.io/2020/05/31/Core-Java-Chapter9/","excerpt":"","text":"Chapter9 Collections9.1 The Java Collections FrameworkJava最初只提供了很少但最有用的一系列数据结构：Vector, Stack, Hashtable, BitSet, Enumeration （Interfaces） Java1.2，设计者认为是时候推出full-fledged的数据结构，不像C++的STL那么复杂但又要想STL一样generic 9.1.1 Separating Collection Interfaces and Implementation1. queueFIFO：先进先出 123456public interface Queue&lt;E&gt;&#123; void add(E element); // add at the tail E remove(); // remove at the head int size();&#125; 两种实现： 循环数组 链表（LinkedList） You don’t need to know which implementation is actually used. Therefore, it makes sense to use the concrete class only when you construct the collection object. Use the interface type to hold the collection reference. Queue staff = new LinkedList&lt;&gt;(); 循环数组一般来说会稍微更有效，但循环数组是一个有界限的集合——有限的容量，所以当不确定队列的具体上限时，推荐使用链表 还有一些命名以Abstract开头的集合，是为了library implementers更好的实现自己的集合类 9.1.2 The Collection Interface最基本的接口是Collection，有两个基本方法 12345public interface Collection&lt;E&gt;&#123; boolean add(E element); // return true if the collection actually changes Iterator&lt;E&gt; iterator();&#125; 9.1.3 Iterators四个方法 1234567public interface Iterator&lt;E&gt;&#123; E next(); boolean hasNext(); void remove(); default void forEachRemaining(... action);&#125; reach the end, next() throws a NoSuchElementException call hasNext() before next() 1234567891011Collection&lt;String&gt; c = ...Iterator&lt;String&gt; iter = c.iterator();while (iter.hasNext()) &#123; String element = iter.next(); // do something with element&#125;// \"for each\" loopfor (String element : c) &#123; // do something with element&#125; 编译器会将”for each”循环用iterator翻译为一个普通的循环，所有实现了Iterable接口的都能使用”for each”循环 还可以调用forEachRemaining() + 匿名函数 1iterator.forEachRemaining(element -&gt; do something with element) Instead, think of Java iterators as being between elements. When you call next, the iterator jumps over the next element, and it returns a reference to the element that it just passed **The remove method of the Iterator interface removes the element that was returned by the last call to next. In many situations, that makes sense—you need to see the element before you can decide that it is the one that should be removed. 12345678// how to remove the first elementIterator&lt;String&gt; iter = c.iterator();iter.next(); // skip over the first elementiter.remove(); // now remove it// 不能在不调用next()的情况下连续使用remove()iter.remove();iter.remove(); // ERROR 9.1.4 Generic Utility MethodsCollection和Iterator都被称为generic, 意味着你能用该方法去操作任意一个collection 9.2 Interfaces in the Collections Framework 最基本的是两个接口: Collection和Map List List是有序的Collection, 两种方式访问元素: by an iterator / by an integer index(random access) LinkedList不支持random access, 所以通过一个tagging interface: RandomAccess去判断是否是linked list 123456if (c instanceof RandomAccess) &#123; use random access algorithms&#125;else &#123; use sequential access algorithms&#125; Set add方法需要避免重复, equals方法忽略顺序, hashCode方法必须使得相同的两个sets生成相同的hash码 TreeSet: 保留顺序的set 9.3 Concrete Collections 9.3.1 Linked ListsArrayList在中间插入或删除一个元素成本太高 a linked list stores each object in a separate link. Each link also stores a reference to the next link in the sequence 实际上是双向链表 删除或添加操作成本大大降低, 只需要修改link ListIterator接口有previous()和hasPrevious()方法可供倒着遍历 add方法在iterator位置的前面加入新元素 set方法用以替换目前iterator调用next()或previous()指向的元素 当一个迭代器在遍历, 另一个在修改时可能会出问题 Concurrent modification detection is done in a simple way. The collection keeps track of the number of mutating operations (such as adding and removing elements). Each iterator keeps a separate count of the number of mutating operations that it was responsible for. At the beginning of each iterator method, the iterator simply checks whether its own mutation count equals that of the collection. If not, it throws a ConcurrentModificationException 一些常用的方法: toString(): 将对象中的元素以一定的格式转为String contains(E element): 是否存在某个元素 offerFirst(E element) offerLast(E element) E pollFirst(): 返回并删除链表的第一个元素 E pollLast() 一般用于作为队列的底层数据结构 1Queue&lt;T&gt; queue = new LinkedList&lt;&gt;(); 9.3.2 Array ListsAn ArrayList encapsulates a dynamically reallocated array of objects 为什么不用Vector All methods of the Vector class are synchronized 9.3.3 Hash Sets哈希表, 对每个对象计算一个哈希值, 放入相应的”桶”中, 所以自定义类时, 要实现相应的hashCode方法 Java中哈希表的底层实现是链表数组, 每个链表称为一个桶 从Java8开始, 当一个链表中元素达到一个阈值(默认8)时将会转为红黑树 一般设置桶个数为75% - 150%的预期元素个数, 标准桶的个数应该是2的幂次, 默认是16 当桶装满时, 就需要重新计算哈希(rehash), 设置承载因子: The load factor determines when a hash table is rehashed. For example, if the load factor is 0.75 (which is the default) and the table is more than 75% full, it is automatically rehashed with twice as many buckets. 9.3.4 Tree Setssorted collection 加入时任意顺序, 但是访问时是按照一定的排序规则排序好的 目前的底层实现是红黑树 使用tree set时, 对象一定要实现了Comparable接口, 或者为set提供一个Comparator 9.3.5 Queues and Deques对于Queue, 添加删除以及查看队首都有两个方法, 区别在于出现问题时抛出异常或是返回false/null add offer 队列满时add抛出IllegalStateException, offer返回false remove poll 队列空时remove抛出NoSuchElementException, poll返回null element peek 队列空时element抛出NoSuchElementException, peek返回null 9.3.6 Priority Queues每次取队首时, 得到的是按照一定规则排序的第一个(比如降序排列, 队首就是最大值) 但是本身并不是完全顺序的, 底层实现是堆 同样需要对象实现Comparable或者提供Comparator 9.4 Maps9.4.1 Basic Map OperationsHashMap和TreeMap, 与set类似, HashMap没有顺序, TreeMap有顺序 12345HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(\"Robin\", 22);String name = \"\";int age = map.get(\"Robin\");int age2 = map.getOrDefault(name, 0); 键值必须唯一, 对相同键重复赋值会覆盖, 同时返回了前一个值 remove() 删除给定键的元素 size() 返回个数 forEach() 配合匿名函数做相应处理 1scores.forEach((k, v) -&gt; System.out.println(\"key=\" + k + \"value=\" + v)); putAll() 将另一个map的entries全部加入到当前map containsKey() containsValue() 9.4.2 Updating Map Entries12345678counts.put(word, counts.get(word) + 1); // 键不存在时get会返回nullcounts.put(word, counts.getOrDefault(word, 0) + 1);counts.putIfAbsent(word, 0);counts.put(word, counts.get(word) + 1);counts.merge(word, 1, Integer::sum); 9.4.3 Map ViewskeySet()不是HashSet或TreeSet, 而是一个实现了Set接口的另一个类, 可以当做一般的Collection values() entrySet() 123456for (Map.Entry&lt;String, Employee&gt; entry : staff.entrySet())&#123; String k = entry.getKey(); Employee v = entry.getValue(); // do something with k, v&#125; 在keySet view中remove相当于删除了map的一个项, 但是无法添加 9.4.4 Weak Hash Maps存在垃圾回收问题, 当map中某个值对应的键不会再被使用, 也不会被回收 As long as the map object is live, all buckets in it are live and won’t be reclaimed. Thus, your program should take care to remove unused values from long-lived maps. Or, you can use a WeakHashMap instead. This data structure cooperates with the garbage collector to remove key/value pairs when the only reference to the key is the one from the hash table entry. WeakHashMap内部使用weak references保存键 However, if the object is reachable only by a WeakReference, the garbage collector still reclaims the object, but places the weak reference that led to it into a queue. The operations of the WeakHashMap periodically check that queue for newly arrived weak references. The arrival of a weak reference in the queue signifies that the key was no longer used by anyone and has been collected. The WeakHashMapthen removes the associated entry. 对于一般不再被引用的对象, 垃圾收集器直接回收, 对于weak reference, 同样回收, 但也会放入一个队列中, 然后map去移除相应的项 9.4.5 Linked Hash Sets and Maps 记录了加入的顺序, 可用于实现LRU 123456var lru = new LinkedHashMap&lt;K, V&gt;(128, 0.75F, true)&#123; protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; 100; &#125; &#125;; 9.4.6 Enumeration Sets and Maps 9.4.7 Identity Hash Maps键不是由hashCode算出而是System.identityHashCode 相同键对象尽管内容相同也被认为是不同的 9.5 Views and Wrappers9.5.1 Small Collectionsstatic函数, 直接给定若干元素形成一个Collection 12345678List&lt;String&gt; names = List.of(\"n1\", \"n2\");Set&lt;Integer&gt; numbers = Set.of(2, 3);Map&lt;String, Integer&gt; scores = Map.of(\"n1\", 2, \"n2\", 3);Map&lt;String, Integer&gt; scores = ofEntries( entry(\"Peter\", 2), entry(\"Paul\", 3), entry(\"Mary\", 5));List&lt;String&gt; settings = Collections.nCopies(100, \"DEFAULT\"); Arrays.asList()返回的list无法调整大小, 即只能使用set而不能add或remove 9.5.2 SubrangessubList()左闭右开 1List&lt;Employee&gt; group = staff.subList(10, 20); // extract 10 to 19 subSet(E from, E to) headSet(E to) tailSet(E from) subMap(K from, K to) headMap(K to) tailMap(K from) 9.5.6 A Note on Optional Operations在API说明中, 很多接口中的方法被称为”optional operations”, 看上去与接口本身的定义是相悖的, 但是如果接口中每一个方法都要被实现的话, 接口的数目可能就会太多了 9.6 Algorithms9.6.1 Why Generic Algorithms?方便重用 比如求最大值, 对于几乎所有数据结构(数组, 列表, 链表)几乎都是遍历所有元素通过比较得出最大值, 那么可定义为泛型函数 12345678910111213public static &lt;T extends Comparable&gt; T max(Collection&lt;T&gt; c)&#123; if (c.isEmpty()) throw new NoSuchElementException(); Iterator&lt;T&gt; iter = c.iterator(); T largest = iter.next(); while (iter.hasNext()) &#123; T next = iter.next(); if (largest.compareTo(next) &lt; 0) largest = next; &#125; return largest;&#125; 9.6.2 Sorting and Shufflingsort12345var staff = new LinkedList&lt;Employee&gt;();Collections.sort(staff);staff.sort(Comparator.comparingDouble(Employee::getSalary)); // 通过雇员工资排序staff.sort(Comparator.reverseOrder); // 按b.compareTo(a)排序staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed()); //按工资逆序 Java中链表的排序方法是: 先将所有元素放入一个数组, 数组排序后再重建回链表 modifiable, resizable modifiable: 支持set方法 resizable: 支持add和remove 能排序的列表必须modifiable但不需要resizable shuffle12ArrayList&lt;Card&gt; cards = . . .;Collections.shuffle(cards); 如果列表本身不支持RandomAccess, 那么shuffle会先将所有元素丢入数组, shuffle后再放回去 9.6.3 Binary Search12i = Collections.binarySearch(c, element);i = Collections.binarySearch(c, element, comparator); 如果找到了, 返回的index为非负整数, 通过c.get(index)可访问该元素 如果没找到, 返回的index是负数, 同时也是有意义的, -index-1表示的是将该元素插入数组并保持有序的下标, 不是-i的原因是下标0会是模糊的 123if (i &lt; 0) &#123; c.add(-i-1, element);&#125; 二分查找要求RandomAccess切排序, 否则没有任何优势了 9.6.4 Simple Algorithms1234567891011Collections.replaceAll(words, \"C++\", \"Java\")words.removeIf(w -&gt; w.length() &lt;= 3)words.replaceAll(String::toLowerCase)Collections.fill(List&lt;? super T&gt; l, T value)Collections.swap(List&lt;?&gt; l, int i, int j)Collections.reverse(List&lt;?&gt; l)Collections.frequency(list, \"2\")Collections.rotate(List&lt;?&gt; l, int d)Collections.copy(List&lt;? super T&gt; to, List&lt;T&gt; from) // target list must be at least as long as the source liststatic &lt;T&gt; min(Collection&lt;T&gt; elements, Comparator&lt;? super T&gt; c)static &lt;T&gt; max(Collection&lt;T&gt; elements, Comparator&lt;? super T&gt; c)","categories":[{"name":"Notes","slug":"Notes","permalink":"http://roooooobin.github.io/categories/Notes/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://roooooobin.github.io/tags/Java/"},{"name":"Core Java","slug":"Core-Java","permalink":"http://roooooobin.github.io/tags/Core-Java/"}]},{"title":"Wordpress网站搭建","slug":"Wordpress网站搭建","date":"2020-05-30T12:53:35.000Z","updated":"2020-05-31T09:00:48.990Z","comments":true,"path":"2020/05/30/Wordpress网站搭建/","link":"","permalink":"http://roooooobin.github.io/2020/05/30/Wordpress%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/","excerpt":"","text":"终于搭成了个人博客，也理应做个小小的回忆录，如果能有幸帮到一些小伙伴完成搭建自然更好，不过由于是回忆，难免会有疏漏了——2019.1.25 Wordpress博客已经废弃，重新在github托管下重建了新个人博客，希望能坚持下去吧——2020.5.30 总体来说搭建博客就是两步，配置服务器+在服务器上安装wordpress博客平台，以下就是大致的搭建过程 1.购买云服务器既然要搭建网站，服务器自然是必不可少的，这里推荐阿里云的学生服务器，还能享受一段时间的学生红利，只需要9.5元一个月，相当的划算 在搜索栏中搜索学生服务器 选择云服务器ECS，CentOS环境及自选的地域和时长，立即购买 购买完毕后进入控制台，进入服务器的管理界面，就可以看到服务器的公网IP地址 至此，拥有了属于自己的服务器 2.使用SSH工具远程连接服务器我们的网站是在服务器上搭建的，拥有了服务器之后需要通过一些远程连接工具连接到服务器，这样的工具不胜枚举，在此推荐Termius，下载完毕后，需要添加host，点击 主要是在栏填写服务器的IP地址，其他的按此前设置的填写即可（用户名一般是root，密码是购买服务器后设置的实例密码），这样会一直保存一个host而不用每次登入服务器都需要输入密码了 至此，成功地通过Termius连接到了服务器 3.在服务器上安装一些基本工具在上一步通过Termius登录到服务器之后，是没有可视化界面的，一切操作都是在命令行中输入相应命令完成，而且这个时候服务器是个空空如也的空壳，需要安装一些基本的工具，暂时有用的没用的都先装上 123456yum install vimyum install gityum install unzipyum install screenyum install gccyum install wget 也可以使用yum install -y ... 这样是自动确认下载，不需要每次手动确认 当然，如果不太确定，也可以等着后面需要，按照提示去下载，完成博客的搭建，上述所安装的工具是足够了 4.一键安装LNMPLNMP代表的是：Linux系统下Nginx+MySQL+PHP的网站服务器架构，简单来说就是搭建wordpress框架的预环境 推荐一个一键安装的教程，按照教程中一步步做就能快速简洁的完成LNMP安装，在此简述大致步骤 在Termius命令行下输入screen -S lnmp 使用SSH远程登录linux时，如果连接非正常中断，重新重新连接时，系统将开一个新的session，无法恢复原来的session。screen命令可以解决这个问题。screen工具是一个终端多路转接器，在本质上，这意味着你能够使用一个单一的终端窗口运行多终端的应用 安装LNMP稳定版，在命令行下输入wget http://soft.vpser.net/lnmp/lnmp1.5.tar.gz -cO lnmp1.5.tar.gz &amp;&amp; tar zxf lnmp1.5.tar.gz &amp;&amp; cd lnmp1.5 &amp;&amp; ./install.sh lnmp 确定版本和选项，安装好之后会提供若干选项供选择，比如数据库的选择是MySQL或MariaDB，然后选择版本，其实可以一路回车选择默认的，没有什么问题 如果显示表示LNMP安装完成，如果失败就要自行查阅失败原因了，应该会很顺利的成功 然后还有一步需要确认，就是在浏览器上输入http://你的IP地址，是否会显示一个welcome界面，应该是这样的如果没有出现，在Termius命令行下输入lnmp start，可能会出现这样的提示信息，可以通过lnmp stop; lnmp start重新启动来解决 然后在阿里云安全组)，选择配置规则)，新添加一条80端口入方向规则 这样之后应该就能顺利看到上述所说的欢迎界面了，表示LNMP安装成功 至此第一步服务器方面的基本环境搭建就全部完成了，接下来就是第二大步，在服务器上搭建wordpress 5.安装wordpress官网提供了下载链接和安装教程，按照官网的教程一步步执行应该是可以顺利完成安装的，不过在zzw的帮助下，我只做了官网教程的前一步，后续的工作按照zzw的教导，描述如下 安装wordpress，由于我们已经可以使用Termius访问服务器，所以在本机上是没有必要下载的，在命令行下输入wget https://wordpress.org/latest.tar.gz然后解压tar -xzvf latest.tar.gz，将wordpress安装在/home/wwwroot/default目录下，最好不要放入文件夹，而是直接所有文件放在default目录下 完成了第一步之后，需要建立数据库，由于我们安装LNMP时安装的是MySQL，所以参照教程中的MySQL部分 adminusername=root databasename=wordpress wordpressusername=root hostname=localhost password=你设置的数据库的密码 完成了数据库的配置后，跳转到wordpress文件目录下cd /home/wwwroot/default，将权限从root改为wwwchown -R www:www ./*，然后删除目录下的index.html，保留index.php 这个时候，先暂停一下，到阿里云服务控制台中使用实例快照备份一下，以免后续动作出现错误后没有历史版本回滚 快照完成后，浏览器进入http://你的IP地址/index.php，会出现界面 数据库名写 wordpress，用户名应该是 root，密码是安装LNMP的时候设置的SQL密码，主机写localhost或者127.0.0.1:3306，表前缀写wp_ 然后开FTP权限给wordpress，进入服务器，输入cd /home/wwwroot/default/wp-content; mkdir tmp; chmod -R 0777 ./tmp; vim ../wp-config.php，在vim文本编辑器中找到 在if (!defined(&#39;ABSPATH&#39;) define...)这句话之后添加四句话 1234define(&#39;WP_TEMP_DIR&#39;,ABSPATH.&#39;wp-content&#x2F;tmp&#39;);define(&quot;FS_METHOD&quot;,&quot;direct&quot;);define(&quot;FS_CHMOD_DIR&quot;,0777);define(&quot;FS_CHMOD_FILE&quot;,0777); 正确示例： lnmp restart之后，进入http://你的IP地址/wp-admin/options-general.php进行基本设置，如果暂时没有域名，wordpress地址填写http://你的IP地址即可，后续有了域名之后再修改 这个时候进入http://你的IP地址（或域名），就会惊喜、惊讶、感动、激动地发现你的博客就这样神奇的搭成了，激动之余再次快照一波 搭成之后，你可以在后台完成一些基本设置，更换喜欢的主题，安装一些好用的插件，毕竟是你的博客，do everything you like 按以上步骤，我终于顺利的完成了个人博客的搭建，再次鸣谢zzw的帮助，帮我省下了很多时间，也基本没有踩到坑 希望也能帮到努力搭建博客的你~","categories":[{"name":"Notes","slug":"Notes","permalink":"http://roooooobin.github.io/categories/Notes/"}],"tags":[{"name":"Wordpress","slug":"Wordpress","permalink":"http://roooooobin.github.io/tags/Wordpress/"}]}],"categories":[{"name":"Programming Problem","slug":"Programming-Problem","permalink":"http://roooooobin.github.io/categories/Programming-Problem/"},{"name":"Interview","slug":"Interview","permalink":"http://roooooobin.github.io/categories/Interview/"},{"name":"Notes","slug":"Notes","permalink":"http://roooooobin.github.io/categories/Notes/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://roooooobin.github.io/tags/Java/"},{"name":"Amazon","slug":"Amazon","permalink":"http://roooooobin.github.io/tags/Amazon/"},{"name":"DFS","slug":"DFS","permalink":"http://roooooobin.github.io/tags/DFS/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://roooooobin.github.io/tags/Binary-Search/"},{"name":"BFS","slug":"BFS","permalink":"http://roooooobin.github.io/tags/BFS/"},{"name":"Sorting","slug":"Sorting","permalink":"http://roooooobin.github.io/tags/Sorting/"},{"name":"OA","slug":"OA","permalink":"http://roooooobin.github.io/tags/OA/"},{"name":"Core Java","slug":"Core-Java","permalink":"http://roooooobin.github.io/tags/Core-Java/"},{"name":"Wordpress","slug":"Wordpress","permalink":"http://roooooobin.github.io/tags/Wordpress/"}]}